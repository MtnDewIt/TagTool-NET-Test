using System;
using System.Collections.Generic;
using System.Linq;
using TagTool.Cache;
using TagTool.Commands.Common;
using TagTool.Common;
using TagTool.Tags.Definitions;
using static TagTool.Tags.Definitions.MultiplayerGlobals.MultiplayerUniversalBlock;

namespace TagTool.Commands.Modding
{
    public class SetCustomizationFromModelCommand : Command
    {
        private GameCache CacheContext { get; }

        public SetCustomizationFromModelCommand(GameCache cacheContext)
            : base(false,
                   "SetCustomizationFromModel",
                   "Sets a customization block in a multiplayer_globals tag to mirror regions and permutations from a model tag. " +
                   "For each permutation, its description is generated by appending '_description' to its original string (using the StringTable), " +
                   "and a variant block is created containing the region and permutation.",
                   "SetCustomizationFromModel [mulg_tag_path] [customization_index] [model_tag_path] [variant_index (optional)]",
                   null)
        {
            CacheContext = cacheContext;
        }

        public override object Execute(List<string> args)
        {
            // Validate arguments.
            if (args.Count < 3)
            {
                Console.WriteLine("Usage: SetCustomizationFromModel [mulg_tag_path] [customization_index] [model_tag_path] [variant_index (optional)]");
                return false;
            }

            // The virtual tag path for the multiplayer_globals tag.
            string mulgPath = args[0];

            if (!int.TryParse(args[1], out int customizationIndex))
            {
                Console.WriteLine("Invalid customization index.");
                return false;
            }

            // The virtual tag path for the model tag.
            string modelPath = args[2];

            int variantIndex = 0;
            if (args.Count >= 4)
            {
                if (!int.TryParse(args[3], out variantIndex))
                {
                    Console.WriteLine("Invalid variant index.");
                    return false;
                }
            }

            // Retrieve the CachedTag for the multiplayer_globals tag from the cache context.
            if (!CacheContext.TagCache.TryGetCachedTag(mulgPath, out CachedTag mulgTagDefinition))
            {
                Console.WriteLine($"Could not find tag: {mulgPath}");
                return false;
            }

            MultiplayerGlobals mulgTagInstance;
            try
            {
                using (var stream = CacheContext.OpenCacheRead())
                {
                    // Deserialize using the tag cache entry.
                    mulgTagInstance = CacheContext.Deserialize<MultiplayerGlobals>(stream, mulgTagDefinition);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading mulg tag: {ex.Message}");
                return false;
            }

            // Retrieve the CachedTag for the model tag.
            if (!CacheContext.TagCache.TryGetCachedTag(modelPath, out CachedTag modelTagDefinition))
            {
                Console.WriteLine($"Could not find tag: {modelPath}");
                return false;
            }

            Model modelTagInstance;
            try
            {
                using (var stream = CacheContext.OpenCacheRead())
                {
                    modelTagInstance = CacheContext.Deserialize<Model>(stream, modelTagDefinition);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading model tag: {ex.Message}");
                return false;
            }

            if (modelTagInstance == null || modelTagInstance.Variants == null || modelTagInstance.Variants.Count == 0)
            {
                Console.WriteLine("Model or its variants not found.");
                return false;
            }

            // Choose the model variant.
            if (variantIndex < 0 || variantIndex >= modelTagInstance.Variants.Count)
            {
                Console.WriteLine("Variant index not specified or invalid. Defaulting to variant 0.");
                variantIndex = 0;
            }
            var modelVariant = modelTagInstance.Variants[variantIndex];

            // Retrieve the customization list.
            // Assumes that the customizable characters are stored in Universal[0].CustomizableCharacters.
            var customizationList = mulgTagInstance.Universal?[0]?.CustomizableCharacters;
            if (customizationList == null || customizationIndex < 0 || customizationIndex >= customizationList.Count)
            {
                Console.WriteLine("Invalid customization index for multiplayer_globals.");
                return false;
            }
            var customization = customizationList[customizationIndex];

            // Ensure the customization regions list is initialized.
            if (customization.Regions == null)
                customization.Regions = new List<CustomizedModelCharacter.Region>();

            // Build a lookup of existing regions (by their StringId).
            Dictionary<StringId, CustomizedModelCharacter.Region> existingRegions = new Dictionary<StringId, CustomizedModelCharacter.Region>();
            foreach (var region in customization.Regions)
            {
                if (region.Name != StringId.Invalid)
                    existingRegions[region.Name] = region;
            }

            // Process each region from the model variant.
            foreach (var modelRegion in modelVariant.Regions)
            {
                if (modelRegion.Name == StringId.Invalid)
                    continue;

                CustomizedModelCharacter.Region customRegion;
                if (!existingRegions.TryGetValue(modelRegion.Name, out customRegion))
                {
                    customRegion = new CustomizedModelCharacter.Region
                    {
                        Name = modelRegion.Name,
                        Permutations = new List<CustomizedModelCharacter.Region.Permutation>()
                    };
                    customization.Regions.Add(customRegion);
                }

                // Process permutations from the model region.
                var validModelPermutations = modelRegion.Permutations?
                    .Where(p => p.Name != StringId.Invalid)
                    .ToList() ?? new List<Model.Variant.Region.Permutation>();

                int targetPermCount = validModelPermutations.Count;

                if (customRegion.Permutations == null)
                    customRegion.Permutations = new List<CustomizedModelCharacter.Region.Permutation>();

                // Remove any invalid permutation entries.
                customRegion.Permutations.RemoveAll(p => p.Name == StringId.Invalid);

                // Adjust the count of permutations to match the model.
                while (customRegion.Permutations.Count < targetPermCount)
                {
                    var newModelPerm = validModelPermutations[customRegion.Permutations.Count];
                    var newPerm = new CustomizedModelCharacter.Region.Permutation
                    {
                        Name = newModelPerm.Name,
                        // Generate the new description by retrieving the original string and appending "_description".
                        Description = CacheContext.StringTable.GetOrAddString(
                                          CacheContext.StringTable.GetString(newModelPerm.Name) + "_description"),
                        Variant = new List<CustomizedModelCharacter.Region.Permutation.VariantBlock>()
                    };
                    customRegion.Permutations.Add(newPerm);
                }
                while (customRegion.Permutations.Count > targetPermCount)
                {
                    customRegion.Permutations.RemoveAt(customRegion.Permutations.Count - 1);
                }

                // Update each permutation.
                for (int i = 0; i < targetPermCount; i++)
                {
                    var modelPerm = validModelPermutations[i];
                    var customPerm = customRegion.Permutations[i];

                    customPerm.Name = modelPerm.Name;
                    customPerm.Description = CacheContext.StringTable.GetOrAddString(
                        CacheContext.StringTable.GetString(modelPerm.Name) + "_description");

                    // Create or clear the variant block list.
                    if (customPerm.Variant == null)
                        customPerm.Variant = new List<CustomizedModelCharacter.Region.Permutation.VariantBlock>();
                    else
                        customPerm.Variant.Clear();

                    var newVariantBlock = new CustomizedModelCharacter.Region.Permutation.VariantBlock
                    {
                        Region = customRegion.Name,
                        Permutation = customPerm.Name
                    };

                    customPerm.Variant.Add(newVariantBlock);
                }
            }

            // Write the updated multiplayer_globals tag back into the cache.
            try
            {
                using (var stream = CacheContext.OpenCacheReadWrite())
                {
                    CacheContext.Serialize(stream, mulgTagDefinition, mulgTagInstance);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing updated mulg tag: {ex.Message}");
                return false;
            }

            Console.WriteLine("Customization updated from model successfully.");
            return true;
        }
    }
}
